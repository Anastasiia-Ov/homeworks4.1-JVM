## Код для исследования```java/*    Перед началом вызова метода main() происходит подгрузка всех классов     в область памяти Metaspace:        с помощью Bootstrap ClassLoader - String, Object, Integer, System;        с помощью Application ClassLoader - JvmComprehension;        с помощью Platform ClassLoader ничего не подгружается, т.к. нет         зависимостей с внешними библиотеками.    Далее идет подготовка классов к выполнению и после - инициализация.*/public class JvmComprehension {    public static void main(String[] args) { // запуск приложения, создается фрейм в стеке        int i = 1;                      // 1         Object o = new Object();        // 2        Integer ii = 2;                 // 3        printAll(o, i, ii);             // 4        System.out.println("finished"); // 7    }    private static void printAll(Object o, int i, Integer ii) { //         Integer uselessVar = 700;                   // 5        System.out.println(o.toString() + i + ii);  // 6    }}/*    1) создание и инициализация примитивной переменной "i"             -> объявлена на стеке int i = 1 (во фрейме main).        2) создание нового объекта класса Object -> размещение в куче,    далее объявляем ссылку на него под названием "о"             -> объявлена на стеке (во фрейме main).         3) создание и инициализация объекта Integer -> размещение в куче,    далее объявляем ссылку на него под названием "ii"             -> объявлена на стеке (во фрейме main).    В Integer переменные хранят ссылки на значения, а не сами значения.        4) вызов нового метода printAll() -> создание второго фрейма в стеке,    и передача аргументов в метод:         - Object o: объявление новой ссылки под названием "о"                    на уже созданный объект Object (который уже лежит в куче)                    -> "о" объявлена на стеке (во фрейме printAll).        - int i: создается копия значения переменной "i" (метода main) и передается                 в новую переменную int i, которая относится к методу printAll                -> "i" объявлена на стеке (во фрейме printAll).        - Integer ii: объявление новой ссылки под названием "ii"                    на уже созданный объект Integer (который уже лежит в куче)                    -> "ii" объявлена на стеке (во фрейме printAll).                       5) создание и инициализация нового объекта Integer -> размещение в куче,    далее объявляем ссылку на него под названием "uselessVar"             -> объявлена на стеке (во фрейме printAll).        6) вызов нового системного метода println(), куда передаем ссылки на объекты     класса Object и Integer и так же новую копию значения переменной "i"         -> создание третьего фрейма "println()" в стеке,            внутри него объявляются: "o", "int i = 1", "ii"    уже в куче происходит преобразование объекта Object в String (o.toString())     и конкатенация с "i" и "ii"    результат конкатенации выводится в консоль и мы выходим из метода println(),     фрейм "println()" тут же исчезнет со стека.         Далее: так как метод printAll() тоже полностью отработан, мы возвращаемся     обратно в метод main() и фрейм "printAll()" так же исчезает со стека.     Остается в стеке только один фрейм "main()"        7) Снова вызов нового метода println(), куда передается ссылка на     объект String, который создался в куче        -> появляется новый фрейм в стеке "println()"     Происходит вывод строки в консоль и фрейм "println()" исчезает.         Так же код в методе main() отработан полностью - фрейм "main()"     тоже исчезает, и стек остается пустой.    Программа завершена.         Про сборщик мусора:    Сборщик мусора работает автоматически, он запускается в то время,     когда программе требуется дополнительная память.     Он определяет достижимые и недостижимые объекты в куче.     Если от объекта невозможно прийти к корневой ссылке,     которая создается в выполняемом коде, то такие объекты удаляются.     Еще куча разделена на сегменты - молодое и старое поколение,     чтобы оптимизировать процесс сборки мусора.     Каждый объект относится к своему поколению в зависимости от того,     сколько сборок мусора он пережил.         Посмотрев на код выше, сразу можно сказать, что сборщик мусора     в первую очередь удалит объект String со значением "finished"     (System.out.println("finished"))*/```